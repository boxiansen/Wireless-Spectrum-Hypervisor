#include "phy.h"

#define ENABLE_RX 1

#define ENABLE_TX 1

extern int errno;

static phy_t *phy_context = NULL;

//*******************************************************
// ************ Program arguments processing ************
//*******************************************************
void args_default(transceiver_args_t *args) {
  args->logging_frequency = 30000; // how frequent the log happens in milliseconds.
  args->single_log_duration = 1000; // duration of a single log in milliseconds.
  args->rnti = 0x1234;
  args->path_to_log_files = "./"; // location of the directory to collect log
  args->enable_cfo_correction = true; // By default CP-based CFO correction is enabled.
  args->nof_prb = 6;
  args->nof_ports = 1;
  args->rf_args = "";
  args->radio_center_frequency = 2400000000.0; // By default, if no center frequency is set, the center frequency will be 2.4 GHz.
  args->initial_rx_gain = 70.0; // AGC is disabled by default and the initial gain given to the RX chain is 70 dB. It will set the maximum gain in x310.
  args->initial_tx_gain = 25.0; // Default Tx gain. Amplifier non-linearities will cause interference to other teams (OOB emisisons) for gains greater than 25 dB
  args->path_to_start_file = "./start_iq_sample_capture.txt", // full path to the file generated by start.sh
  args->node_operation = -1; // 0 - RX, 1 - TX, -1 - Automatic configuration via phy control.
  args->node_id = 0; // SRN node ID. Each node can have a number spanning from 0 up to 255.
  args->max_number_of_dumps = 1, // Maxium number of dump files to be created.
  args->sensing_rx_gain = 0; // RX gain that should be applied to the specific channel RX cahin. Value given in dB.
  args->radio_id = 0; // By default all radio IDs are zero, meaning the Cell-ID is 0.
  args->use_std_carrier_sep = true; // By default, we use LTE standard sampling rates according to the the FFT size.
  args->initial_agc_gain = 50.0;
  args->competition_bw = 20000000.0; // Competition bandwidth is by default set to 20 MHz.
  args->default_tx_channel = 0;
  args->default_rx_channel = 0;
  args->lbt_threshold = 1000.0; // By default we set the channel threshold to 1000 dBm. In other others, LBT is disabled when threshold is too high.
  args->lbt_timeout = 10000000000000; // This parameter is given in milliseconds.
  args->max_turbo_decoder_noi = 4; // By default the maximum number of Turbo decoding iterations is set to 4.
  args->phy_filtering = false; // By default PHY filtering is disabled.
  args->iq_dump_data_type = SRSLTE_COMPLEX_SHORT_BIN; // By default we write complex<short> into file in order to get smaller files.
  args->rf_monitor_rx_sample_rate = 23040000.0; // By default the RF Monitor module will sample at 23.04 MHz.
  args->rf_monitor_channel = RF_MONITOR_CHANNEL; // By default we set the rf_monitor channel to 1.
  args->lbt_use_fft_based_pwr = false; // By default we use time-domain based power measurements.
  args->send_tx_stats_to_mac = false; // By default we do not send TX statistics to MAC as it does not use it for now.
  args->max_backoff_period = 32; // By default the maximum backoff period is set to 15.
  args->iq_dumping = false; // By default we never create IQ dumping files.
  args->immediate_transmission = false; // By default immediate transmissions are not allowed.
  args->add_tx_timestamp = false;
  args->rf_monitor_option = 100; // By default no rf monitor modules is set as the rf monitor option.
  args->initial_subframe_index = 5; // By default subframe is 5. Set the subframe index number to be used to start from. When add_preamble_to_front is set to true, then it is set to subframe 1.
  args->rf_boost = 0.8; // RF Boost.
  args->freq_boost = 1.0; // Frequency domain boost.
  args->radio_nof_prb = 100; // Number of PRBs for the radio transmissions.
  args->num_of_tx_vphys = 1; // Default number of virtual Tx PHYs to start.
  args->num_of_rx_vphys = 1; // Default number of virtual Rx PHYs to start.
  args->phy_cylic_prefix = SRSLTE_CP_NORM; // Default CP is the nromal one.
  args->add_preamble_to_front = false; // By default preamble is added to the middle of the slot (i.e., subframe)
  args->enable_ifft_adjust = false; // By default iFFT adjustment is not enabled.
  args->modulate_with_zeros = 0; // By default this should be always set to 0.
  args->window_type = WINDOW_LIQUID; // By default we use the liquid dsp window if windowing is enabled.
  args->plot_rx_info = false; // By default plotting is disabled.
  args->vphy_id_rx_info = 0; // By default, if plot is enabled, then vPHY Rx ID 0 is plot.
  args->channelizer_filter_delay = 8; // By default, the delay is set to 8, however it could be as low as 1.
  args->pss_peak_threshold = 3.0; // PSS peak detection threshold.
  args->decode_pdcch = false; // By default we always try to decode SCH sequences instead of PDCCH control channel.
}

void usage(transceiver_args_t *args, char *prog) {
  printf("Usage: %s [abcegiplomnsxqzwAXBEPCRdDVWvrfuUSZTIFLMNGh]\n", prog);
  printf("\t-a RF args [Default %s]\n", args->rf_args);
  printf("\t-b RF boost. [Default %s]\n", args->rf_boost);
  printf("\t-e Frequency domain boost. [Default %s]\n", args->freq_boost);
  printf("\t-B Set competition bandwidth [Default %1.2f MHz]\n", args->competition_bw/1000000.0);
  printf("\t-A Add preamble to front of the slot instead of the middle [Default %s]\n", args->add_preamble_to_front?"Enabled":"Disabled");
  printf("\t-g Set RX gain [Default %.1f dB]\n", args->initial_rx_gain);
  printf("\t-t Set TX gain [Default %.1f dB]\n", args->initial_tx_gain);
  printf("\t-l Set LBT threshold. Values greater than or equal to 100 dB disable LBT. [Default %1.0f dB]\n", args->lbt_threshold);
  printf("\t-o Set LBT timeout [Default %d milliseconds]\n", args->lbt_timeout);
  printf("\t-q Enable IQ dumping. Options are on/off [Default %s]\n", args->iq_dumping?"on":"off");
  printf("\t-c Use FFT based power measurements [Default %s]\n", args->lbt_use_fft_based_pwr?"Enabled":"Disabled");
  printf("\t-z Use immediate transmissions [Default %s]\n", args->immediate_transmission?"Enabled":"Disabled");
  printf("\t-x Enable transmission of TX statistics to MAC layer [Default %s]\n", args->send_tx_stats_to_mac?"True":"False");
  printf("\t-X Set maximum backoff period [Default %d]\n", args->max_backoff_period);
  printf("\t-i Radio ID [Default: %d]\n",args->radio_id);
  printf("\t-n PHY Filtering [Default %d]\n", args->phy_filtering);
  printf("\t-N Add timestamp to TX packet [Default %d]\n", args->add_tx_timestamp);
  printf("\t-f Competition center frequency at which the PHY and the sensing modules should operate on (in Hz) [Default %.1f Hz]\n",args->radio_center_frequency);
  printf("\t-p Set number of Physical Resource Blocks (nof_prb) [Default %d]\n", args->nof_prb);
  printf("\t-u Set number of Radio Physical Resource Blocks (radio_nof_prb) [Default %d]\n", args->radio_nof_prb);
  printf("\t-P Enable vPHY Rx info plot. [Default %s, ID: %d]\n", args->plot_rx_info?"TRUE":"FALSE", args->vphy_id_rx_info);
  printf("\t-r Set the initial Rx channel for vPHY ID 0, the others are this plus vPHY ID [Default %d]\n", args->default_rx_channel);
  printf("\t-C Enable CFO correction [Default %s]\n", args->enable_cfo_correction?"Enabled":"Disabled");
  printf("\t-s RX sampling rate for RF monitor module [Default %1.2f]\n", args->rf_monitor_rx_sample_rate);
  printf("\t-m Maximum number of turbo decoder iterations [Default %d]\n", args->max_turbo_decoder_noi);
  printf("\t-S Path to check for start dumping file [Default %s]\n", args->path_to_start_file);
  printf("\t-L Path where the IQ dump files should be stored [Default %s]\n", args->path_to_log_files);
  printf("\t-I Node ID [Default %d]\n", args->node_id);
  printf("\t-F Logging frequency in milliseconds, frequency in milliseconds with which dump files should be created [Default %d]\n", args->logging_frequency);
  printf("\t-D Single log file duration in milliseconds [Default %d]\n", args->single_log_duration);
  printf("\t-M Maximum number of dumping files to be created [Default %d]\n", args->max_number_of_dumps);
  printf("\t-G Gain given to the sensing RX chain [Default %1.2f]\n", args->sensing_rx_gain);
  printf("\t-d [set development debug level, default disabled]\n");
  printf("\t-v [set scatter_verbose_level to debug, default none]\n");
  printf("\t-Z Use non-standard sampling rates, [Default %d]\n",args->use_std_carrier_sep);
  printf("\t-R Number of Rx vPHYs to start [Default %d]\n", args->num_of_rx_vphys);
  printf("\t-T Number of Tx vPHYs to start [Default %d]\n", args->num_of_tx_vphys);
  printf("\t-V Set the RF monitor module to be started. [Default %d]\n", args->rf_monitor_option);
  printf("\t-w Set the subframe index to be used to start from. [Default %d]\n", args->initial_subframe_index);
  printf("\t-E Apply ifft adjustment. [Default %s]\n", args->enable_ifft_adjust?"Enabled":"Disabled");
  printf("\t-W Modulate all subcarriers with 0. [Default %d]\n", args->modulate_with_zeros);
  printf("\t-h Print this help message\n");
}

void parse_args(transceiver_args_t *args, int argc, char **argv) {
  int opt;
  args_default(args);
  while((opt = getopt(argc, argv, "abcdeogiplmnsxqzwAEXBPOCDVvrfuUSZTIFLMNGRWht0123456789")) != -1) {
    switch (opt) {
    case 'A':
      args->add_preamble_to_front = true;
      args->initial_subframe_index = 1;
      PHY_PRINT("Add preamble to front of the slot and change initial subframe to 1.\n",0);
      break;
    case 'i':
      args->radio_id = atoi(argv[optind]);
      break;
    case 'p':
      args->nof_prb = helpers_get_prb_from_bw(atoi(argv[optind]));
      PHY_PRINT("Requested vPHY BW: %d - Mapped vPHY PRB: %d\n",atoi(argv[optind]), args->nof_prb);
      break;
    case 'u':
      args->radio_nof_prb = atoi(argv[optind]);
      PHY_PRINT("Number of Radio PRB: %d\n",atoi(argv[optind]), args->radio_nof_prb);
      break;
    case 'n':
      args->phy_filtering = true;
      PHY_PRINT("PHY filtering is enabled.\n", 0);
      break;
    case 'N':
      args->add_tx_timestamp = true;
      PHY_PRINT("Addition of TX timestamp is enabled.\n",0);
      break;
    case 'W':
      args->modulate_with_zeros++;
      PHY_PRINT("Modulation test enabled: %d\n",args->modulate_with_zeros);
      break;
    case 'P':
#if(ENBALE_VPHY_RX_INFO_PLOT==1)
      args->plot_rx_info = true;
      args->vphy_id_rx_info = atoi(argv[optind]);
      PHY_PRINT("Plot of vPHY Rx info for ID: %d enabled.\n", args->vphy_id_rx_info);
#else
      PHY_PRINT("Plot of vPHY Rx info needs to be enabled and compiled.\n",0);
#endif
      break;
    case 'a':
      PHY_PRINT("RF args: %s\n",argv[optind]);
      args->rf_args = argv[optind];
      break;
    case 'l':
      args->lbt_threshold = atof(argv[optind]);
      PHY_PRINT("LBT threshold: %1.2f\n",args->lbt_threshold);
      PHY_PRINT("LBT checking is %s\n",args->lbt_threshold < 100.0?"Enabled":"Disabled");
      break;
    case 'o':
      args->lbt_timeout = atoll(argv[optind]);
      PHY_PRINT("LBT timeout: %" PRIu64 "\n",args->lbt_timeout);
      break;
    case 'q':
      if(strcmp("on", argv[optind]) == 0) {
        args->iq_dumping = true;
        // If IQ dumping is on then the RF monitor option must be 0, meaning, IQ Dump module.
        args->rf_monitor_option = 4;
      } else if(strcmp("off", argv[optind]) == 0) {
        args->iq_dumping = false;
      } else {
        args->iq_dumping = false;
      }
      PHY_PRINT("IQ dumping: %s\n",args->iq_dumping?"on":"off");
      break;
    case 'V':
      if(strcmp("iq_dumping", argv[optind]) == 0) {
        args->rf_monitor_option = 0;
      } else if(strcmp("lbt", argv[optind]) == 0) {
        args->rf_monitor_option = 1;
      } else if(strcmp("rssi_monitor", argv[optind]) == 0) {
        args->rf_monitor_option = 2;
      } else if(strcmp("spectrum_sensing", argv[optind]) == 0) {
        args->rf_monitor_option = 3;
      } else if(strcmp("iq_dump_plus_sensing", argv[optind]) == 0) {
        args->rf_monitor_option = 4;
      } else {
        args->rf_monitor_option = 100;
      }
      PHY_PRINT("RF monitor option: %d\n",args->rf_monitor_option);
      break;
    case 'B':
      args->competition_bw = atof(argv[optind]);
      PHY_PRINT("Competition BW: %.2f [MHz]\n",args->competition_bw/1000000.0);
      break;
    case 'b':
      args->rf_boost = atof(argv[optind]);
      PHY_PRINT("RF boost: %f\n",args->rf_boost);
      break;
    case 'e':
      args->freq_boost = atof(argv[optind]);
      PHY_PRINT("Frequency domain boost: %f\n",args->freq_boost);
      break;
    case 'g':
      args->initial_rx_gain = atof(argv[optind]);
      break;
    case 't':
      args->initial_tx_gain = atof(argv[optind]);
      break;
    case 'c':
      args->lbt_use_fft_based_pwr = true;
      PHY_PRINT("FFT based power measurement is enabled.\n",0);
      break;
    case 'z':
      args->immediate_transmission = true;
      PHY_PRINT("Immediate transmissions are enabled.\n",0);
      break;
    case 'w':
      args->initial_subframe_index = atoi(argv[optind]);
      PHY_PRINT("Initial subframe index set to: %d\n",args->initial_subframe_index);
      break;
    case 'x':
      args->send_tx_stats_to_mac = true;
      PHY_PRINT("Transmission of PHY TX stats to MAC layer is enabled.\n",0);
      break;
    case 'X':
      args->max_backoff_period = atoi(argv[optind]);
      PHY_PRINT("Maximum backoff period set to: %d\n",args->max_backoff_period);
      break;
    case 'R':
      args->num_of_rx_vphys = atoi(argv[optind]);
      PHY_PRINT("Number of Rx vPHYs to start: %d\n",args->num_of_rx_vphys);
      break;
    case 'T':
      args->num_of_tx_vphys = atoi(argv[optind]);
      PHY_PRINT("Number of Tx vPHYs to start: %d\n",args->num_of_tx_vphys);
      break;
    case 'C':
      args->enable_cfo_correction = false;
      PHY_PRINT("CFO correction disabled\n",0);
      break;
    case 'f':
      args->radio_center_frequency = strtod(argv[optind], NULL);
      PHY_PRINT("Center frequency: %1.3f [MHz]\n",args->radio_center_frequency/1000000.0);
      break;
    case 'r':
      args->default_rx_channel = atoi(argv[optind]);
      PHY_PRINT("Initial Rx channel for vPHY ID 0: %d\n",args->default_rx_channel);
      break;
    case 'd':
      development_debug_level++;
      break;
    case 'v':
      scatter_verbose_level++;
      break;
    case 'm':
      args->max_turbo_decoder_noi = atoi(argv[optind]);
      PHY_PRINT("Max. turbo decoding iterations: %d\n",args->max_turbo_decoder_noi);
      break;
    case 's':
      args->rf_monitor_rx_sample_rate = atof(argv[optind]);
      PHY_PRINT("RF Monitor sampling rate: %1.2f [MHz]\n",args->rf_monitor_rx_sample_rate/1000000.0);
      break;
    case 'Z':
      args->use_std_carrier_sep = false;
      PHY_PRINT("Using Non-standard sampling rates.\n",0);
      break;
    case 'E':
      args->enable_ifft_adjust = true;
      PHY_PRINT("Enable iFFT adjustment.\n",0);
      break;
    case 'S':
      args->path_to_start_file = argv[optind];
      break;
    case 'D':
      args->single_log_duration = atoi(argv[optind]);
      break;
    case 'L':
      args->path_to_log_files = argv[optind];
      break;
    case 'I':
      args->node_id = atoi(argv[optind]);
      if(args->node_id >= MAXIMUM_NUMBER_OF_RADIOS) {
        PHY_PRINT("Invalid Node ID: %d. It has to be less than %d.\n", args->node_id, MAXIMUM_NUMBER_OF_RADIOS);
        exit(-1);
      }
      PHY_PRINT("SRN ID: %d\n",args->node_id);
      break;
    case 'F':
      args->logging_frequency = atoi(argv[optind]);
      break;
    case 'M':
      args->max_number_of_dumps = atoi(argv[optind]);
      break;
    case 'G':
      args->sensing_rx_gain = atof(argv[optind]);
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      break;
    case 'h':
    default:
      usage(args, argv[0]);
      exit(-1);
    }
  }
}

void change_process_priority(int inc) {
  errno = 0;
  // Set priority of main thread.
  //uhd_set_thread_priority(1.0, true);
  // Set nice to highest priority.
  if(nice(inc) == -1) {
    if(errno != 0) {
      PHY_ERROR("Something went wrong with nice(): %s - Perhaps you should run it as root.\n", strerror(errno));
    }
  }
}

void initialize_rf_monitor(uint32_t rf_monitor_option, transceiver_args_t *prog_args) {
#if(ENABLE_SW_RF_MONITOR==1)
  if(ENABLE_SENSING_THREAD && rf_monitor_option <= 4) {
    int rc = rf_monitor_initialize(prog_args);
    if(rc) {
      PHY_ERROR("ABORTING... it was not possible to start the sensing module.\n",0);
      exit(-1);
    }
  }
#endif
}

void uninitialize_rf_monitor(uint32_t rf_monitor_option) {
#if(ENABLE_SW_RF_MONITOR==1)
   if(ENABLE_SENSING_THREAD && rf_monitor_option <= 4) {
     int rc = rf_monitor_uninitialize();
     if(rc) {
       PHY_ERROR("ABORTING... It was not possible to uninitialize the sensing module.\n",0);
       exit(-1);
     }
     PHY_PRINT("RF monitoring uninitialization done!\n",0);
   }
#endif
 }

 void phy_sig_int_handler(int signo) {
   if(signo == SIGINT) {
     phy_context->run_phy = false;
     PHY_INFO("SIGINT received. Exiting...\n",0);
   }
 }

 void phy_initialize_signal_handler() {
   sigset_t sigset;
   phy_context->run_phy = true;
   sigemptyset(&sigset);
   sigaddset(&sigset, SIGINT);
   sigprocmask(SIG_UNBLOCK, &sigset, NULL);
   signal(SIGINT, phy_sig_int_handler);
 }

 inline bool phy_is_running() {
   return phy_context->run_phy;
 }

//*************************************************************************
//                            BEGIN OF MAIN
//*************************************************************************
int main(int argc, char **argv) {

  // Allocate memory for a PHY object.
  phy_context = (phy_t*)srslte_vec_malloc(sizeof(phy_t));
  // Check if memory allocation was correctly done.
  if(phy_context == NULL) {
    PHY_ERROR("Error allocating memory for PHY context\n", 0);
    exit(-1);
  }

  // Change process priority.
  change_process_priority(-20);

  // Initialize signal handler.
  phy_initialize_signal_handler();

  // Parse command line arguments.
  parse_args(&phy_context->prog_args, argc, argv);

  //*********************************************************
  //************** Initialization of modules ****************
  //*********************************************************
  PHY_INFO("Start initialization of modules.\n",0);

  // Register watchdog callback.
#if(ENABLE_WATCHDOG_TIMER==1)
  if(timer_register_callback(phy_watchdog_handler) < 0) {
    PHY_ERROR("Not possible to register watchdog callback.\n",0);
    exit(-1);
  }
#endif

  // Initialize Hypervisor control module.
  hypervisor_ctrl_initialize(&phy_context->prog_args);
  // Keep hypervisor Tx timer id's address for checking.
  phy_context->hyper_tx_timer_id = hypervisor_ctrl_get_hyper_tx_timer_id();
  PHY_INFO("Initialization of PHY hypervisor control module done!\n",0);

  // Initialize PHY communicator control module.
  phy_comm_ctrl_initialize(&phy_context->prog_args);
  PHY_INFO("Initialization of PHY communication module done!\n",0);

#if(ENABLE_RX==1)
  // Initialize and start the specified number of vPHYs Rx threads.
  PHY_INFO("Starting %d vPHY Rx threads.\n", phy_context->prog_args.num_of_rx_vphys);
  for(uint32_t vphy_id = 0; vphy_id < phy_context->prog_args.num_of_rx_vphys; vphy_id++) {
    if(vphy_rx_start_thread(&phy_context->prog_args, vphy_id) < 0) {
      PHY_ERROR("Error starting vPHY #%d Rx thread.\n", vphy_id);
      exit(-1);
    }
    // Keep vPHY Rx sync timer id's address for checking.
    phy_context->vphy_rx_timer_ids[vphy_id] = vphy_rx_get_sync_timer_id(vphy_id);
    PHY_INFO("vPHY Rx ID: %d started.\n", vphy_id);
  }
  PHY_INFO("Initialization of all vPHY Rx threads done!\n", 0);
  // Inform Hypervisor Rx that all vPHY Rx are running and waiting for samples from the channelizer.
  hypervisor_ctrl_set_vphy_rx_running_flag(true);
#endif

#if(ENABLE_TX==1)
  // Initialize and start the specified number of vPHYs Tx threads.
  PHY_INFO("Starting %d vPHY Tx threads.\n", phy_context->prog_args.num_of_tx_vphys);
  for(uint32_t vphy_id = 0; vphy_id < phy_context->prog_args.num_of_tx_vphys; vphy_id++) {
    if(vphy_tx_start_thread(&phy_context->prog_args, vphy_id) < 0) {
      PHY_ERROR("Error starting vPHY #%d Tx thread.\n", vphy_id);
      exit(-1);
    }
    // Keep vPHY Tx timer id's address for checking.
    phy_context->vphy_tx_timer_ids[vphy_id] = vphy_tx_get_timer_id(vphy_id);
    PHY_INFO("vPHY Tx ID: %d started.\n", vphy_id);
  }
  PHY_INFO("Initialization of all vPHY Tx threads done!\n", 0);
#endif

  PHY_PRINT("-------------------------------------------------\n\n",0);

#if(ENABLE_SW_RF_MONITOR==1)
  // Initialize rf monitor: After setting the Master clock rate we can start the rf monitor thread only if the number of opened channels is greater than 1.
  initialize_rf_monitor();
#endif

  //*********************************************************
  //******* Handle messages coming from uper layers *********
  //*********************************************************
  // Call function that will handle all messages sent by upper layers.
  phy_comm_ctrl_control_work();

  //*********************************************************
  //************* Uninitialization of modules ***************
  //*********************************************************
  PHY_INFO("Start uninitialization of modules...\n",0);

#if(ENABLE_SW_RF_MONITOR==1)
  // Free all resources used by the sensing module.
  uninitialize_rf_monitor();
#endif

#if(ENABLE_TX==1)
  // Uninitialize the specified number of vPHYs Tx threads.
  for(uint32_t vphy_id = 0; vphy_id < phy_context->prog_args.num_of_tx_vphys; vphy_id++) {
    if(vphy_tx_stop_thread(vphy_id) < 0) {
      PHY_ERROR("Error stopping vPHY #%d Tx thread.\n", vphy_id);
      exit(-1);
    }
    PHY_INFO("vPHY Tx ID: %d stopped.\n", vphy_id);
  }
  PHY_INFO("Uninitialization of all vPHY Tx threads done!\n",0);
#endif

#if(ENABLE_RX==1)
  // Uninitialize the specified number of vPHYs Rx threads.
  for(uint32_t vphy_id = 0; vphy_id < phy_context->prog_args.num_of_rx_vphys; vphy_id++) {
    if(vphy_rx_stop_thread(vphy_id) < 0) {
      PHY_ERROR("Error stopping vPHY #%d Rx thread.\n", vphy_id);
      exit(-1);
    }
    PHY_INFO("vPHY Rx ID: %d stopped.\n", vphy_id);
  }
  PHY_INFO("Uninitialization of all vPHY Rx threads done!\n",0);
  // Inform Hypervisor Rx that all vPHY Rx were stopped.
  hypervisor_ctrl_set_vphy_rx_running_flag(false);
#endif

  // Uninitialize PHY communicator control module.
  phy_comm_ctrl_uninitialize();
  PHY_INFO("Uninitialization of PHY communication module done!\n",0);

  // Uninitialize Hypervisor control module.
  hypervisor_ctrl_uninitialize();
  PHY_INFO("Uninitialization of PHY hypervisor control module done!\n",0);

  // Free memory used to store PHY object.
  if(phy_context) {
    free(phy_context);
    phy_context = NULL;
  }

  PHY_PRINT("Bye...\n",0);
  exit(0);
}

#if(ENABLE_WATCHDOG_TIMER==1)
static void phy_watchdog_handler(int sig, siginfo_t *info, void *ptr) {
  // Print a string that will be used by the PHY watchdog.
  PHY_PRINT("PHY_Watchdog_Activated\n", 0);
  // Verify if the Hypervisor Tx actived the watchdog.
  if(info->si_value.sival_ptr == phy_context->hyper_tx_timer_id) {
    PHY_PRINT("Watchdog activated by Hypervisor Tx.\n", 0);
  }
  // Verify if one of the vPHY Rx threads actived the watchdog.
  for(uint32_t vphy_id = 0; vphy_id < phy_context->prog_args.num_of_rx_vphys; vphy_id++) {
    if(info->si_value.sival_ptr == phy_context->vphy_rx_timer_ids[vphy_id]) {
      PHY_PRINT("Watchdog activated by vPHY Rx ID: %d thread.\n", vphy_id);
    }
  }
  // Verify if one of the vPHY Tx threads actived the watchdog.
  for(uint32_t vphy_id = 0; vphy_id < phy_context->prog_args.num_of_tx_vphys; vphy_id++) {
    if(info->si_value.sival_ptr == phy_context->vphy_tx_timer_ids[vphy_id]) {
      PHY_PRINT("Watchdog activated by vPHY Tx ID: %d thread.\n", vphy_id);
    }
  }
}
#endif
